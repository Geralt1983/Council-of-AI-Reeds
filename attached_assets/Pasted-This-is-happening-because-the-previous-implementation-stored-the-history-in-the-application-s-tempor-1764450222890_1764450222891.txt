This is happening because the previous implementation stored the history in the application's temporary memory (State). When you refresh the page or the app restarts, that memory is wiped clean.
To fix this, we need to save the history to the browser's Local Storage. This acts like a "save file" that persists even when you close the tab.
The Fix: Client-Side Persistence
Update client/src/lib/simulation.ts. We will modify how the history state is initialized and add a listener to save changes automatically.
File: client/src/lib/simulation.ts
import { useState, useCallback, useEffect } from "react";
import { useMutation } from "@tanstack/react-query";
import { apiRequest } from "./queryClient";
import { useToast } from "@/hooks/use-toast";

export type SimulationState = "idle" | "thinking" | "judging" | "consensus";

export interface Worker {
  id: string;
  name: string;
  role: string;
  color: string;
  avatar: string;
  description: string;
}

export const WORKERS: Worker[] = [
  { id: "worker-a", name: "The Skeptic", role: "Analyst", color: "var(--worker-a)", avatar: "üîç", description: "Looks for risks." },
  { id: "worker-b", name: "The Visionary", role: "Creative", color: "var(--worker-b)", avatar: "üé®", description: "Proposes novel ideas." },
  { id: "worker-c", name: "The Realist", role: "Pragmatist", color: "var(--worker-c)", avatar: "‚öôÔ∏è", description: "Focuses on efficiency." }
];

export interface Draft {
  workerId: string;
  content: string;
  status: "pending" | "complete";
}

export interface HistoryItem {
  id: string;
  query: string;
  result: string;
  date: string;
  score: number;
}

export function useCouncilSimulation() {
  const { toast } = useToast();
  
  // --- STATE ---
  const [status, setStatus] = useState<SimulationState>("idle");
  const [round, setRound] = useState(0);
  const [query, setQuery] = useState("");
  const [drafts, setDrafts] = useState<Draft[]>([]);
  const [critique, setCritique] = useState<string | null>(null);
  const [score, setScore] = useState(0);
  const [consensus, setConsensus] = useState<string | null>(null);

  // 1. Initialize History from Local Storage
  const [history, setHistory] = useState<HistoryItem[]>(() => {
    try {
      const saved = localStorage.getItem("council_history");
      return saved ? JSON.parse(saved) : [];
    } catch (e) {
      console.error("Failed to load history:", e);
      return [];
    }
  });

  // 2. Save History to Local Storage whenever it changes
  useEffect(() => {
    try {
      localStorage.setItem("council_history", JSON.stringify(history));
    } catch (e) {
      console.error("Failed to save history:", e);
    }
  }, [history]);

  // --- API MUTATION ---
  const mutation = useMutation({
    mutationFn: async (payload: { query: string; previousCritique?: string | null }) => {
      const res = await apiRequest("POST", "/api/council/run-round", payload);
      return res.json();
    },
    onSuccess: (data) => {
      setDrafts(data.drafts.map((d: any) => ({ ...d, status: "complete" })));
      setCritique(data.evaluation.critique);
      setScore(data.evaluation.score);
      setStatus("judging");

      if (data.evaluation.stop || data.evaluation.score >= 90 || round >= 2) {
        setTimeout(() => {
          setStatus("consensus");
          setConsensus(data.evaluation.synthesis);
          
          // Add to History
          const newItem: HistoryItem = {
            id: Date.now().toString(),
            query: query,
            result: data.evaluation.synthesis,
            date: new Date().toLocaleString(), // Added time for better tracking
            score: data.evaluation.score
          };
          
          setHistory(prev => [newItem, ...prev]);
        }, 2000);
      } else {
        setTimeout(() => {
          setRound(prev => prev + 1);
          setStatus("thinking");
          triggerRound(query, data.evaluation.critique);
        }, 4000);
      }
    },
    onError: () => {
      toast({ title: "Error", description: "Council connection failed.", variant: "destructive" });
      setStatus("idle");
    }
  });

  const triggerRound = (q: string, crit?: string | null) => {
    setDrafts(WORKERS.map(w => ({ workerId: w.id, content: "", status: "pending" })));
    mutation.mutate({ query: q, previousCritique: crit });
  };

  const startSimulation = useCallback((userQuery: string) => {
    setQuery(userQuery);
    setStatus("thinking");
    setRound(1);
    setConsensus(null);
    setScore(0);
    triggerRound(userQuery);
  }, []);

  const reset = useCallback(() => {
    setStatus("idle");
    setQuery("");
    setDrafts([]);
    setConsensus(null);
  }, []);

  const loadHistory = useCallback((item: HistoryItem) => {
    setQuery(item.query);
    setConsensus(item.result);
    setScore(item.score);
    setStatus("consensus");
    setDrafts([]); 
  }, []);

  // Optional: Function to clear history if needed
  const clearHistory = useCallback(() => {
    setHistory([]);
    localStorage.removeItem("council_history");
  }, []);

  return {
    status,
    round,
    query,
    drafts,
    critique,
    score,
    consensus,
    startSimulation,
    reset,
    history,
    loadHistory,
    clearHistory
  };
}

